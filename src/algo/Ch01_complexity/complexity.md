## 复杂度分析（Complexity Analysis）

### 1.时间复杂度
#### 1.1 Big O表示法
- O(n)中的n表示的是数据规模
- O(f(n))表示运行算法所需的指令数，和f(n)成正比
    > 比如：二分查找法O（logn），所需的指令数为a*logn，a为常数
- 在学术中，O(f(n))表示算法执行的上界，在业内我们使用O表示算法执行的下界。
- 如果一个算法中有两部分组成，那么整体的算法复杂度将由复杂度高的那部分主导。另外，复杂度中可能存在多个数据规模，不能将它们混淆。
- 算法的复杂度还和测试用例相关，我们一般去平均情况
    > 比如：插入排序的复杂度为O(n^2),最差时为O(n^2)，最好时O(n)，平均为O(n^2)。
    
#### 1.2 数据规模的概念
要想在1s内完成运行，各个复杂度处理的数据规模如下
- O(n^2)算法：可以处理10^4的数据
- O(nlogn)算法：可以处理10^7的数据
- O(n)算法：可以处理10^8的数据

如果算法的每次执行比较庞大，那么各个算法处理的数据规模可以再降一个数量级。

### 2. 空间复杂度
对于一个算法需要开辟的辅助空间的大小：
- 多开一个常数空间：O(1)
- 多开一个数组：O(n)
- 多开一个二维数组：O(n^2)
递归调用是有空间代价的。

递归的深度是多少，整个递归过程的空间复杂度就是多少。

### 3. 复杂度实验
如何判断算法属于哪个级别的的，有这样的方法：
- 根据在1s内能够处理的数据规模来判断
- 编写测试代码，从数据规模和时间消耗两个维度绘制图表
    - O(n^2)：数据规模扩大1倍，时间消耗会变成原来的4倍
    - O(nlogn)：数据规模扩大一倍，时间消耗会增加1倍多一点，此算法性能与O(n)算法相当
    - O(n)：数据规模扩大一倍，时间消耗也会增加1倍
    - O(logn)：数据规模扩大1倍，时间消耗增加的很少，数据规模越大，优势越明显
    
### 4. 复杂度的一些认识
- 对于算法复杂度O(logn),我们是不需要考虑对数的底数的，不管是log<sub>2</sub>N还是log<sub>10</sub>n，都称为logN的算法
    > 对于log<sub>a</sub>N和log<sub>b</sub>N,有这样的式子：  
    ![](https://raw.githubusercontent.com/Daffupman/markdown-img/master/20190726183850.png)  
    其中log<sub>a</sub>b是一个常数。所以，所有的对数级别的复杂度都统一看成是O(logn)的。
- 一些特殊的情况
    - 双重循环却是O(nlogn)的算法：
    ![](https://raw.githubusercontent.com/Daffupman/markdown-img/master/20190726184553.png)
    - 单次循环却是O(sqrt(n))的算法：  
    ![](https://raw.githubusercontent.com/Daffupman/markdown-img/master/20190726184741.png)
- 递归算法并不都是O(nlogn)级别的，可能是O(logn)级别的，也可能是O(n)级别的，甚至是O(2^n)级别的。
- 复杂度的的排序
    > O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)
    
### 5. 均摊复杂度（Amortized Time）